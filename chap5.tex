\chapter{\'Etoil\'e}

\'Etoil\'e is an experimental run-time written by David Chisnall, a Research Associate in the University of Cambridge Computer Lab. It has been written as a part of his paper called \emph{A Modern Objective-C Runtime}\footnote{http://www.jot.fm/issues/issue\_2009\_01/article4/index.html}. Even though it is not a real-world run-time (i.e.\ no compiler supports it in its full extent and has been claimed to be mostly experimental), it has introduced quite a few interesting ideas how to speed up the method lookup time as well as make the run-time more generic.

Unlike the previously described run-times, the \'Etoil\'e run-time tackles the task of providing a run-time from a totally different angle. While the other implementations simply aim to create a traditional Objective-C run-time, where Apple chooses to keep almost all of the original API for its Objective-C 2.0, \'Etoil\'e run-time tries to create a very generic run-time that could be used with many other languages as well, which would result in a very easy language bridging - a mechanism, where objects from one language can be interacted with from another language and vice versa. Even though deprecated, Apple was supplying a Java - Objective-C bridge for quite some time\footnote{http://cocoadevcentral.com/articles/000024.php}, for example.

This task, however, required to start from scratch and leave all compatibility behind. As the author notes, the run-time API itself has never been standardized, unlike the language, so a person should not rely that much on it. Hence all the functions, such as \verb=objc_msgSend=, \verb=objc_getClass=, or \verb=sel_registerName= are not available in this run-time. The data structures are modified, or completely missing - for example \verb=SEL= is defined as a \verb=uint32_t=, which is a hash for an internal representation of the selector, \verb=objc_selector= structure, which contains name and a type string, like in GCC's run-time. 

The source code of this run-time is much shorter than the other implementations - according to the author the run-time is just 15\% of the size of GCC's implementation. It needs to be taken into account, however, that this run-time doesn't provide some of the modern features of the other run-times. The source code includes many macros that are in fact to be generated by the compiler, as well - the speed of the run-time relies on the compiler a lot as well.

\section{Slots}
Instead of defining methods, the more generic approach is to define slots. A slot is the basic type for message lookup - a structure containing five fields: \verb=int offset=, \verb=IMP method=, \verb=char *types=, \verb=void *context= and \verb=uint32_t version=. This allows the run-time to store both properties and methods using a single structure: as the properties, introduced in Objective-C 2.0 run-time, are just wrappers around automatically generated getter and setter methods, this approach allows to define a property simply using a slot that has a defined \verb=offset= field, which represents an offset of a variable in the object's structure. By setting the \verb=method= field of the slot, the slot works like a regular method.

As has been mentioned, the run-time was built to meet needs of other languages as well, for example JavaScript (and other prototype-based languages), where variables may be added to an object dynamically and inherit not just from a class, but from another object as well. This can be done by adding a slot, which holds the value as well - in the \verb=context= field of the structure.

Whenever the structure gets updated (\verb=IMP= is changed, etc.), the version is increased. This is important later on for caching.


\section{Inline Caching}
Using monomorphic or polymorphic inline caching, the author of the \'Etoil\'e run-time was able to achieve impressive speeds, reducing the method call time to only twice the time of a pure C function call, which is faster than the C++ method calls are.

With every dynamic object-oriented language, a question arises, how to fetch the function that actually implements a method. This lookup function is usually the critical part of the run-time's performance. As the lookup can be expensive (climbing the whole class hierarchy, all methods of each class), all of the run-times described here use some caching mechanisms.

Imagine a class \verb=FCButton=, which is a subclass of \verb=NSButton=, which is a subclass of \verb=NSControl=, \verb=NSView=, \verb=NSResponder=, \verb=NSObject=. There are many methods that are implemented only by a class far above the receiver's class in the class hierarchy. For example the very commonly used \verb=retain= and \verb=release= methods, are most likely implemented only on the \verb=NSObject= root class. If the dispatch had to lookup a method each time in the method lists declared on the classes, the lookup function would have to climb the whole class hierarchy, until it found the class that implemented the method.

For this reason, caching has been introduced. Both Apple's and GCC's run-times use a cache. When the user wants to call a method, first the run-time looks into the cache (which is usually very fast) and returns the method, if it has been found. Otherwise, it looks up the method in the class hierarchy and caches it into the cache for further use.

An issue here is that when the implementation of a method in some class changes, all cache entries with the original function pointer need to be removed. The same applies when a new module has been loaded with a class category - a category may replace an already-existing method of that class.

But even this lookup costs something. The approach of \'Etoil\'e run-time is for the compiler to generate inline caches as well.

Every time a method is supposed to be called, the following lookup macro is applied. This example uses the monomorphic cache. Unless you assume the same message will sent to objects of different classes, it is well sufficient. The polymorphic cache may be useful for class clusters (for example, \verb=NSString= - which can be of multiple different classes, depending whether it's a constant string, created by run-time, etc.), or if you are expecting subclasses to be passed as well.

\begin{figure}[H]
\begin{verbatim}
#define SLOT_LOOKUP_MIC(obj, sel_name, sel_types, sender, action)\
do\
{\
    static SEL selector = 0;\
    struct objc_slot * slot;\
    if(selector == 0)\
    {\
        selector = lookup_typed_selector(sel_name, sel_types);\
    }\
    static __thread struct inline_cache_line cache;\
    if(cache.slot != NULL \
        &&\
        cache.type == (id)obj->isa\
        &&\
        cache.version == cache.slot->version)\
    {\
        slot = cache.slot;\
    }\
    else\
    {\
        id object = (id)obj;\
        slot = slot_lookup(&obj, selector, sender);\
        if(obj == object)\
        {\
            cache.version = slot->version;\
            cache.slot = slot;\
            cache.type = obj->isa;\
        }\
    }\
    struct objc_call call = { slot, selector, sender };\
    action\
} while(0)
\end{verbatim}
  \centering{}
  \caption{\'Etoil\'e run-time's inline cache.}
  \label{fig:etoile_inline_cache}
\end{figure}


Inline caches are static \verb=__thread= structures, so that each thread has its own cache, removing need for any locks. This is, however, as has been noted above, a GCC extension of the C language that may not be supported on every OS.

This static cache is generated at every place in the code, where a method is called. The selector itself is cached, so no lookup is needed for it either. Then the cache is checked if it is filled with this object's class (i.e. this place in the code has been visited before, but is the object of the same class as before? - if yes, perhaps a polymorphic cache should have been used here instead) and the version matches the slot's version - if the slot has been modified since, the cache is invalidated and filled freshly.

This is something Apple's run-time cannot do, due to their use of \verb=objc_msgSend= family of functions instead of fetching the method implementation and then calling it.

\section{Message Sending}

The traditional message sending, where the method gets translated into a function with the first parameter \verb=self= and the second one \verb=_cmd= has been abandoned for a slightly more complicated, yet more flexible call:

\begin{figure}[H]
\begin{verbatim}
typedef struct objc_call {
  SLOT slot;
  SEL selector;
  id sender;
} *CALL;

#define _cmd (_call->selector)
id method(id self, CALL _call, ...);
\end{verbatim}
  \centering{}
  \caption{\'Etoil\'e run-time's \texttt{CALL} structure.}
  \label{fig:etoile_CALL_struct}
\end{figure}

This extends the original simple \verb=_cmd= of type \verb=SEL=, adding more context to the call. Such context may be used to implement a private inner class, for example, which checks in every method that the \verb=_call->sender='s class is indeed its parent class.

\section{Tags}

A tag is an additional field that isn't declared by the object itself, but is associated with it. Each object has a couple of tags that the run-time installs by default. In particular, each object has its own mutex, refcount (number of references to the object - used for reference-based memory management), size, slots and lookup function.

In Apple's and GCC's run-time, in order to use the \verb=@synchronized= construct, a hash is computed for the object, which determines which lock from a pool of lock should be used. If that particular lock has already been taken by another object, another lock is used. The pool is claimed to be big enough to avoid any contention under normal circumstances. 

Unlike the traditional run-times, in \'Etoil\'e run-time each object has its own mutex to decrease the contention to none at all. Many systems support lazy initialization of a mutex so object creation shouldn't be any slower. This is, however, an assumption about the underlying OS and may have a great effect on the speed of object allocation under operating systems that do not support lazy initialization.

Each object also has its own dispatch table, unlike the other run-times. This allows to change the dispatch at object granularity, i.e.\ swapping method implementations for just one object, adding a method for just one object, etc.

This leads to the last but not least interesting tag, which is the lookup function. A lookup function is a function that goes through the dispatch table of the object and looks for the implementation of a method that is being called. Here, the lookup function may be changed on an per-object basis, which allows to implement proxy objects very efficiently, making proxy calls virtually the same speed as direct calls (by setting the lookup function to a function that looks directly through the target class' methods).

\section{Metaclasses}

Another difference between the \'Etoil\'e run-time and the others is the lack of meta classes. The class methods are simply put into a dispatch table (in this case only a re-defined sparse array) directly on the class. In the traditional run-time, the instance methods are stored on the class, class methods on its meta class.

