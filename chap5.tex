\chapter{Modular Run-Time}
\section{Objectives}

The main objective of this work is to create a prototype of a run-time that will have no dependencies on any external libraries, not even the POSIX ones, allowing the developer to set up his own run-time from different modules.

Also, no constructs that require OS support (dynamic loader, standard OS libraries, etc.) will be used. Such constructs include \verb=static\ __thread= (which creates a new copy of the variable declared for each thread created) or \newline{} \verb=__attribute__((constructor))= (which marks the function to be called by the dynamic loader right after the bundle has been loaded).

This will, however, require for example the user to call some run-time initializing functions as they won't get called by the dynamic loader. On systems that do support the constructor functions, this can be easily avoided by compiling the run-time with an additional file which will declare and implement a constructor 

\subsection{Example 1: Lock-less run-time}
In a single-threaded application, there is no need for any locking whatsoever. All of the existing implementations require some locking, even though they are trying to use lock-free structures, such as sparse arrays that do not support deleting.

But even so, any \verb=@synchronized(obj)= code is translated to actually lock a mutex associated with \verb=obj=, be it either a mutex from a lock pool in the traditional run-times, or a mutex that is associated just with \verb=obj= in the \'Etoil\'e run-time. This can speed up both loading of the application and code execution.

\subsection{Example 2: Kernel usage}

To get the existing run-times working in a kernel of an operating system might be tricky, depending on how much is the kernel POSIX-compatible. But even so, the \verb=malloc= functions and others usually are just wrappers around kernel allocators, which slows down allocation of all structures within the run-time.

Using the modular run-time it will be possible to change the allocator with a simple function-pointer assignment.


\subsection{Example 3: Benchmarking}

The modularity that will be introduced by this work will allow anyone to explore changes in the speed of the run-time simply by changing internal data structures used to hold the class list, selector list and caching. This may help the future development of the run-time.


\section{Run-time Setup}

At the core of the run-time, there is a structure \verb=objc_runtime_setup_struct objc_setup= - while the user has no direct access to this structure, the run-time itself can access it directly for the sake of the speed, to eliminate unnecessary function calls that would serve just as proxy calls.

You can view the structure here:

\begin{verbatim}
  // TODO: paste the final structure when available
typedef struct {
  objc_abort abort;
  objc_allocator allocator;
  struct {
    objc_class_holder_creator creator;
    objc_class_holder_destroyer destroyer;
    objc_class_holder_lookup lookup;
  } class_holder;
} objc_runtime_setup_struct;
\end{verbatim}

This allows the modularity of the run-time. One can, at the beginning of his program, modify all of those pointers using setter functions declared in \verb=runtime.h=. After the runtime has been initialized, however, the whole structure is sealed from changes using those setter functions to prevent any data corruption (as some data structures may be already initialized, changing these functions could lead to bad memory access, etc.). Using any of the setter functions after the run-time has been initialized will lead to a crash of the program (using the abort function supplied).

A description of each of those functions follows:

\subsection{Abort}

It is commonly said that there is no software without bugs - hence it is sometimes necessary to abort the program execution if the program gets into an inconsistent point, or a point where illegal arguments are passed to the environment (for example, setting the run-time setup structure to NULL).

\subsection{Allocator, Deallocator, Reallocator and Zero-allocator}

As the run-time needs new memory for dynamic object creation, an allocator is needed. All existing run-times use \verb=malloc=, which, however, ties them to Unix-based operating systems.

The Modular Run-Time lets you specify your own allocator, which can be, for example, just a wrapper around \verb=malloc= adding some debug logging, or a completely different allocator, e.g.\ a kernel allocator as has been mentioned before. It can also be just the \verb=malloc= function itself, as the function type takes just one argument - the size of the memory required and returns a \verb=void*= pointer.

Sometimes, the memory acquired should be filled with zeros - just as the \verb=calloc= function would do, however, it is called \verb=objc_zero_allocator\ zero_allocator= in this run-time. The \verb=calloc= function can be assigned, however.

For dynamically growing structures, reallocation may be needed - hence the inclusion of the reallocating function. It is pointer-compatible with the \verb=realloc= function.

When the run-time is done with memory it has allocated, it will deallocate it using the deallocate function, which has the same signature as the POSIX \verb=free= function.

\subsection{Arrays}

A lot of the code of the traditional run-times is riddled with code that is takes care of consistency of dynamically growing arrays (or rather arrays of arrays) - there's a lot of duplicate code for functions related to lists of methods, protocols, etc.\ on each class.

This run-time declares a \verb=objc_array= type, which is again just a retyped \verb=void*=, but can be implemented any possible way. The implementation includes a working implementation of such an array and installs these function pointers at initialization, unless other pointers are provided. 


\subsection{Class Holder}

The run-time needs to keep track of all classes that are registered with it. To do so, it needs to keep a list in some data structure. As the run-time is designed to be flexible, it doesn't matter what data structure at all.

There is a defined data type \verb=objc_class_holder= which, however, is only a redefined \verb=void*=. Using the run-times function pointers \verb=class_holder.creator=, \verb=class_holder.destroyer=, \verb=class_holder.lookup= and TODO, the run-time creates the data structure required, has means to destroy it, lookup a class according to its name and TODO.

