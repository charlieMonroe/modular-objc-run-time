\chapter{Future Work}

While the Modular Run-time already provides a lot of capability, there are some features of the other run-times that are missing, or could be worked on in the future. This chapter lists a few of these issues and elaborates how easily this functionality could be added to the Modular Run-time.

\begin{itemize}
  \item{\bf{Compiling information for class extensions}} As the categories are unknown at the compile time and the space they occupy on the \verb=Class= object is dynamically allocated, how does one compile, for example class categories, and register them with the run-time? One possibility is to compile the categories into prototypes, which is easy, register the class prototype and then add the categories to the class. Other alternative is to use the \verb=extra_space= field in the class prototype structure, making it a linked list of extension data prototypes. Each class extension would have a string identifier which would serve to find the correct extension data prototype. To implement this, all that is needed is to modify the class prototype structure and slightly extend the class registering function.
  \item{\bf{\tt{+load} method}} In the traditional run-times, when a method gets registered with the run-time (or loaded from a bundle) and it implements the \verb=+load= method (directly that class, not its superclasses!), it gets called. This can be achieved by adding an extension that calls this method within its \verb=class_initializer= function. This however, would require either for the \verb=+load= method not to use any extensions (as other extensions may not be done with the \verb=class_initializer=s), or somehow make sure it is called as the last. Other solution is to extend the class extension structure with another function pointer, which would get called after the class has been completely initialized and installed into the run-time.
  \item{\bf{\tt{+initialize} method}} Just like the \verb=+load= method, there is a \verb=+initialize= method that gets called before the first method gets to be invoked on that particular class. This can be easily done by installing a class extension with a look-up function, which always returns \verb=NULL=, but when it gets called for the first time for some class, it looks up and calls (itself) the \verb=+initialize= method. The extension may request additional space on the \verb=Class= structure of size \verb=sizeof(BOOL)=, which would be set to \verb=YES= once the method would get to be called.
  \item{\bf{Static object instances and class extensions}} There aren't many cases where static object instances are necessary, however, for example string literals are the case. Since the compiler doesn't know the additional space requested by the class extensions during compile time, class extensions would fail on \verb=__MRConstString= instances. This could get solved by adding an \verb=extra_space= ivar to the class and check the \verb=isa= pointer in the \newline{}\verb=objc_object_extensions_beginning_for_extension= function - if it indeed is the \verb=__MRConstString= class (a single pointer comparison), then see the \verb=extra_space= field - if it is \verb=NULL=, allocate it (similar as with the \verb=extra_space= on the \verb=Class= objects), otherwise, return a pointer from within that dynamically allocated space. This would mean lazily allocated extra space and the class extensions issue would be solved. Unfortunately, the issue that the object initializer functions wouldn't get called cannot be easily solved, however, these functions should only be used for debugging, since everything should be lazily initialized.
  \item{\bf{Synchronization}} The \verb=@synchronize= construct requires some object-related locking, which can, again, be implemented using a class extension, which can decide itself whether to use a pool of locks, or install a lock on each object.
\end{itemize}


