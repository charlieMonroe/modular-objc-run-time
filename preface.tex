\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

While there already are existing Objective-C run-times, a closer look at them will show their weaknesses - mostly their dependencies or assumptions about the underlying OS and environment, where are they supposed to be running. Be it the POSIX layer, minimal object size, or GCC-specific C language extensions, all of these dependencies may present an obstacle when trying to compile such a run-time for a non-typical operating system (for example an experimental one), or when trying to use the Objective-C run-time in the kernel code.

This thesis will analyze source codes of existing versions of Objective-C run-time, their limitations or requirements for compilation. Result of this work will be a prototype of a modular Objective-C run-time, which will allow easy configuration of the run-time environment both at the compilation and run time. For example, for a single-threaded application, you will be able to turn off locking of internal structures without affecting stability, yet performance can be improved (with each message sent\footnote{In Objective-C method calls are called messages being sent to objects, just like in Smalltalk.}, a lock can be potentially locked when the method implementation isn't cached and the class hierarchy has to be searched) - this may save quite a few calls to the kernel.

There are three available Objective-C run-time implementations (to my knowledge) - one is provided by \emph{Apple} and is used in its OS X and iOS systems - there are slight differences between the iOS and OS X versions of the run-time (e.g.\ iOS doesn't support garbage collection and only the new 2.0 run-time is available). Within this thesis, when talking about Apple's implementation of the run-time, the OS X version will be the one talked about. Then there's a run-time provided with \emph{GCC} compiler and a more experimental one called \emph{\'{E}toil\'{e}} which has been used to improve the \emph{GNUStep} run-time\footnote{http://www.jot.fm/issues/issue\_2009\_01/article4/index.html}.

Even though I will mention a few words about the garbage collection and ARC\footnote{ARC - automatic reference counting, a feature introduced in Xcode 4.2 (Xcode is Apple's IDE) that uses compiler's static analysis combined with special keywords to automatically insert retain/release calls so that the developer doesn't need to manually manage reference counts on objects.}, not much attention will be paid to them as garbage collection is being deprecated in OS X 10.8 (and has severe dependencies on the underlying operating system itself) and ARC is a relatively new technology which uses a lot of compiler-dependent features as well as auto-zeroing weak references, etc.; which is beyond the scope of this work. Instead, the focus will be put on the core functionality of the run-time, analysis of the current implementations and designing the modular run-time itself.