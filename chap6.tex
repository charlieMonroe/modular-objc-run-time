\chapter{Modular Run-Time Design}

When thinking about creating a run-time from scratch, one has to think mainly about two things:

\begin{itemize}
  \item{\bf{Speed}} The run-time is the core of every application that uses it. The speed of the applications using the run-time is greatly dependent on the speed of the run-time, the method dispatch in particular.
  \item{\bf{Flexibility}} The run-time should be as flexible as possible. It should be easy to port the run-time to other platforms, and even to kernel space. One should be able to add custom features to the run-time without modifying the run-time's source code - just adding another source code file and possibly even registering it on the fly without the need to recompile the run-time.
\end{itemize}

The main objective of this work is to create a prototype of a completely new run-time that has no dependencies on any external libraries, not even the POSIX layer, thus allowing the developer to easily set up his own run-time from different modules.

Also, no constructs that require any OS support (dynamic loader, standard OS libraries, etc.) will be used. This means, that constructs such as \verb=static __thread= (which creates a new copy of the variable declared for each thread created) or \newline{} \verb=__attribute__((constructor))= (which marks the function to be called by the dynamic loader right after the binary has been loaded) cannot be used either.

In its way, the run-time will be a bare skeleton, which will be ready to be extended for a particular system. As has been mentioned before, the run-time has been designed to be as flexible as possible. This means that all possible dependencies had to be removed, as well as all assumptions about the underlying OS, or whether the run-time is running in user space, or kernel space.

The run-time, however, needs a way to allocate memory, locks, and so on, which are system-specific tasks. The intention behind this run-time is to completely separate these dependencies, so that porting the run-time to another platform is as easy as providing a single file containing all the necessary resources.

This leads to a question how should the run-time allocate any memory, or use any OS-specific functions.

First, all of the OS-specific calls need to be gathered in a single place within the run-time. There needs to be a centralized 'black box', which can be switched with a different 'black box' without the run-time even noticing.

There are two options when to supply the 'black box' to the run-time.

\begin{itemize}
\item{\bf{At compile time}}
The first one is very similar to what the other run-time implementations have done - create a header file that contains multiple static inline functions that implement all the OS-specific calls required by the run-time.

This approach to the platform-independence problem has one advantage and one disadvantage. The obvious disadvantage is that you can perform compile-time changes only. Once the run-time has been compiled, there is no way to change, for example, the allocator without performing some wild hackery exchanging the \verb=malloc= function pointer using the dynamic loader API.

The advantage, on the other hand, is definitely speed. There is no extra cost associated with calling these system APIs as the wrapper functions get inlined.

\item{\bf{At run time}}
Another approach is to create a setup structure that consists of function pointers, which are then called by the run-time. This has the opposite advantages and disadvantages as inlining functions.

The advantage is that the run-time can be compiled without knowing the functions at all and then every program can decide which allocators to use, etc. Or if there is enough support from the dynamic loader, the dynamic loader can decide which functions to use to populate the run-time setup based on some binary flags.

The disadvantage here, on the other hand, is speed. While the function itself has to be called anyway, it is possible that the function types used in the run-time do not match function types in your system. You then need to create a proxy function that converts the parameters.

For example, if the read/write lock functions were made to be compatible with the POSIX \verb=pthread_rwlock_*= functions, which return an \verb=int= containing a possible error value, or zero if the call was successful and the OS you are porting the run-time to does not return anything, or returns a different value than zero for success, you need to create a proxy function that calls the system function and then returns some value accordingly. This, however, costs an extra function call.
\end{itemize}

\section{Initialization of the Run-time}

As the run-time cannot use any compiler-specific extensions, the \verb=constructor= attribute in particular, a question arises, who or what will initialize the run-time in case the variant using function pointers is used.

On systems that do support the constructor functions, this can be easily solved by compiling the run-time with an additional file which declares and implements a function with the \verb=constructor= attribute that supplies necessary function pointers to the run-time.

What if the system does not support constructor functions? In a real-world scenario, it cannot be assumed that every program's \verb=main= function starts by feeding the run-time with necessary function pointers, or calling any initialization function.

If it is possible to tie the run-time with the OS more tightly, the answer is that the dynamic loader should initialize the run-time.

Again, if this is not the case, few options emerge:

\begin{itemize}
  \item{\bf{Use a special \verb=main= function}} Instead of implementing the main function in the program itself, implement it inside the run-time and make it call an external \verb=objc_main= function, which would get to be implemented in the program. It is similar to start of a C program, where the \verb=start= function is called, which initializes some C global variables and then calls the \verb=main= function.
  \item{\bf{Add hooks to class registration}} Second option is to add a check into the class creating/registering functions if the run-time has already been initialized (a global variable may be used for this) and if not, call the initializing function and continue. Class registration function seems like a good place to add such a hook as it does not make sense to call any other functions if no classes have been registered with the run-time. Also, such a check does cost something (an \verb=if= statement), so it is not suitable for any function that gets called more often.
\end{itemize}

\section{Modifying the Run-time at Run Time}

Now that the initialization has been figured out, even on systems that do not support constructors, another question comes up - what about the on-the-fly customization? What if a user wants to customize the run-time at the beginning of his or her program? Here's a few examples a person might want to change:

\begin{itemize}
\item{\bf{Example 1: Lock-less run-time}}
In a single-threaded application (or applications, where you know that Objective-C code will be used only in one thread), there is no need for any locking whatsoever. All of the existing implementations require some locking, even though they are using read-lock-free structures, such as sparse arrays that do not support deleting.

But even so, any \verb=@synchronized(obj)= code is translated to actually lock a mutex associated with \verb=obj=, be it either a mutex from a lock pool in the traditional run-times, or a mutex that is associated just with \verb=obj= in the \'Etoil\'e run-time. This can speed up both loading of the application and code execution.

\item{\bf{Example 2: Kernel usage}}

To get the existing run-times working in a kernel of an operating system might be tricky, depending on how much the kernel is POSIX-compatible. But even so, the \verb=malloc= functions and others usually are just wrappers around kernel allocators, which slows down allocation of all structures within the run-time.

Using the modular run-time, it is be possible to change the allocator with a simple function-pointer assignment.

\item{\bf{Example 3: Benchmarking}}

The modularity that will be introduced by this work will allow anyone to explore changes in the speed of the run-time simply by changing internal data structures used to hold the class list, selector list and caching. This may help the future development of the run-time.

\end{itemize}

Logically, there needs to be some sort of a line after which the run-time cannot be modified as it would lead to inconsistency - for example changing the deallocator after some objects have been already allocated may lead to memory leaks or crashes as the new deallocator will not recognize that particular memory.

Assuming that function pointers are used, you might want to disable all locks in your program as has been described in \textbf{Example 1} above. Even though most operating systems no-op all mutex-related function unless the program is running as multi-threaded. One may, however, be running a multi-threaded application with Objective-C code running in just one thread. Then it may be useful to no-op all the locking functions manually.

Assuming the dynamic loader (or some other part of the OS) already supplied necessary function pointers to the run-time, as otherwise any change to the function pointers would get overwritten. Such a change must be also performed before the 'black box' gets sealed from changes.

Several options helping to catch such a moment emerge:

\begin{itemize}
  \item{\bf{With compiler and dynamic loader support}} If enough support is possible from both, just like the \verb=constructor= attribute, other attributes, such as \verb=objc_constructor= and \verb=objc_modifier= could be used, where the constructor would get called first and the modifiers would follow.
  \item{\bf{Without compiler and dynamic loader support}} As the previous option requires a lot of support from both the compiler and dynamic loader, it is unlikely to be used in less common operating systems, which this work is trying to target as well. For this reason, the run-time should support registering initializer functions that get called right before it finishes initialization and seals the 'black box'. Because the run-time has no way to allocate new memory at the moment of registering the initializer functions, the number of such initializer functions needs to be limited.
  
  This, again, poses a question when does the run-time get initialized. And the answer is simple. The run-time should place a check in a few key functions (such as selector and class registering) and if the run-time has not been initialized, it gets initialized. So what if one calls another function before the initialization? The program is likely to crash since it does not make much sense to call any other function without having registered at least one class.
  
  Note though that this is only to support systems with absolutely no support of anything described above, where the user himself or herself would otherwise need to initialize the run-time at the beginning of \verb=main= - which he or she still can, but it is redundant.
\end{itemize}

\section{Class}

At the core of every run-time lies a structure representing a class. Like the \'Etoil\'e run-time, the Modular Run-Time should not provide a class pair - a class and its meta-class, but only a single class object that contains class methods as well. While it abandons the Smalltalk similarities, it provides greater flexibility, allowing the Objective-C class structure to be used for other languages as well.

So that even the class object can be considered an object, the first field must remain the \verb=isa= pointer, which should point to itself. The pointer cycle is hence introduced on every class, the class being its own instance.

This allows quick detection whether the object is an instance, or a class - just compare the object pointer with its \verb=isa= pointer.

The rest of the class structure is an implementation detail.




