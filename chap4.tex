\chapter{\'Etoil\'e}
\section{What is \'Etoil\'e}

\'Etoil\'e is an experimental run-time written by David Chisnall, a research assistant in computer science at Swansea University. It has been written as a part of his paper called \emph{A Modern Objective-C Runtime}\footnote{http://www.jot.fm/issues/issue\_2009\_01/article4/index.html}. Even though it is not a real-world run-time (i.e.\ no compiler supports it in its full extent and has been claimed to be mostly experimental), it has introduced quite a few interesting ideas how to speed up the method lookup time as well as make the run-time more generic.

Unlike the previously described run-times, the \'Etoil\'e run-time tackles the task of providing a run-time from a totally different angle. While the other implementations simply aim to create a traditional Objective-C run-time, where Apple chooses to keep almost all of the original API for its Objective-C 2.0, \'Etoil\'e run-time tries to create a very generic run-time that could be used with many other languages as well, which would result in a very easy language bridging - a mechanism, where objects from one language can be interacted with from another language and vice versa (even though deprecated, Apple was supplying a Java - Objective-C bridge for quite some time\footnote{http://cocoadevcentral.com/articles/000024.php}).

This task, however, required to start from scratch and leave all compatibility behind. As the author notes, the run-time API itself has never been standardized, unlike the language, so a person shouldn't rely that much on it. Hence all the functions, such as \verb=objc_msgSend=, \verb=objc_getClass=, or \verb=sel_registerName= are not available in this run-time. The data structures are modified, or completely missing - for example \verb=SEL= is defined as a \verb=uint32_t=, which is a hash for an internal representation of the selector, which is a \verb=objc_selector= structure, which contains name and a type string, like in GCC's run-time. 

The source code of this run-time is much shorter than the other implementations - according to the author the run-time is just 15\% of the size of GCC's implementation, however, this run-time doesn't currently provide some of the modern features of run-times. The source code includes many macros that are really to be generated by the compiler as well - the speed of the run-time relies on the compiler a lot as well.

\section{Slots}
Instead of defining methods, the more generic approach is to define slots. A slot is the basic type for message lookup - a structure containing five fields: \verb=int offset=, \verb=IMP method=, \verb=char *types=, \verb=void *context= and \verb=uint32_t version=. This allows the run-time to store both properties and methods using a single structure: as the properties, introduced in Objective-C 2.0 run-time, are just wrappers around automatically generated getter and setter methods, this approach allows to define a property simply using a slot that has a defined \verb=offset= field, which serves as a number of bytes after the beginning of the object is that variable stored. By setting the \verb=method= field of the slot, the slot works like a regular method.

As I have mentioned, the run-time was built to meet needs of other languages as well, for example JavaScript (and other prototype-based languages), where you can dynamically add variables to an object and inherit not just from a class, but from another object as well. This can be done by adding a slot, which will then hold the value as well - in the \verb=context= field of the structure.

Whenever the structure gets updated (\verb=IMP= is changed, etc.), the version is increased. This is important later on for caching.


\section{Inline Caching}
Using monomorphic or polymorphic inline caching, the author of \'Etoil\'e run-time was able to achieve impressive speeds, reducing the method call time to only twice the time of a pure C function call, even faster than the C++ method calls are.

With every dynamic object-oriented language, a question arises, how to fetch the function that actually implements a method. This lookup function is usually the critical part of the run-time's performance. As the lookup can be expensive (climbing the whole class hierarchy), all of the run-times described here use some caching mechanisms.

Imagine your class \verb=FCButton=, which is a subclass of \verb=NSButton=, which is a subclass of \verb=NSControl=, \verb=NSView=, \verb=NSResponder=, \verb=NSObject=. If the dispatch had to lookup each method, for example the very commonly used \verb=retain= and \verb=release=, which are implemented most likely just in the \verb=NSObject= root class, the lookup function would have to climb the whole class hierarchy, until it found the class that implements the method.

For this reason, caching has been introduced. Both Apple's and GCC's run-times have a cache - when the user wants to call a method, the run-time needs to look up the function pointer. First, it looks into the cache (which is usually fast) and returns the \verb=IMP=, if it has been found, otherwise looks up the function pointer in the class hierarchy and saves it into the cache for further use.

An issue here is that when the implementation of a method in some class is changed, all cache entries with the original function pointer need to be removed. The same applies when a new module has been loaded with a class category - a category may replace an already-existing method of that class.

But even this lookup costs something - there's at least one C function call to fetch the data from the cache, plus the actual fetching from the cache. The approach of \'Etoil\'e run-time is for the compiler to generate inline caches.

Every time a method is supposed to be called, the following lookup macro is applied. This example uses the monomorphic cache. Unless you assume the same message will sent to objects of different classes, it is well sufficient. The polymorphic cache may be useful for class clusters (for example, NSString - which can be of multiple different classes, depending whether it's a constant string, created by run-time, etc.), or if you are expecting subclasses of the variable type class to be passed as well.

\begin{verbatim}
#define SLOT_LOOKUP_MIC(obj, sel_name, sel_types, sender, action)\
do\
{\
    static SEL selector = 0;\
    struct objc_slot * slot;\
    if(selector == 0)\
    {\
        selector = lookup_typed_selector(sel_name, sel_types);\
    }\
    static __thread struct inline_cache_line cache;\
    if(cache.slot != NULL \
        &&\
        cache.type == (id)obj->isa\
        &&\
        cache.version == cache.slot->version)\
    {\
        slot = cache.slot;\
    }\
    else\
    {\
        id object = (id)obj;\
        slot = slot_lookup(&obj, selector, sender);\
        if(obj == object)\
        {\
            cache.version = slot->version;\
            cache.slot = slot;\
            cache.type = obj->isa;\
        }\
    }\
    struct objc_call call = { slot, selector, sender };\
    action\
} while(0)
\end{verbatim}


Inline caches are static \verb=__thread= structures (which as has been noted above, is a GCC extension, that needs support from the OS), so that each thread has its own cache. This static cache is created for every place in the code, where a method is called. The selector itself is cached, so no lookup is needed for it either. Then the cache is checked if it is filled with this object's class (i.e. this place in the code has been visited before, but the object has been of another class before - a polymorphic cache should have been used here instead) and the version matches the slot's version - if the slot has been modified since, the cache is invalidated and filled freshly.

\section{Message Sending}

The traditional message sending, where the method gets translated into a function with the first parameter \verb=self= and the second one \verb=_cmd= has been abandoned for a slightly more complicated, yet more flexible call:

\begin{verbatim}
typedef struct objc_call {
  SLOT slot;
  SEL selector;
  id sender;
} *CALL;
#define _cmd (_call->selector)
id method(id self, CALL _call, ...);
\end{verbatim}

This extends the original simple \verb=_cmd= of type \verb=SEL=: it adds more context to the call, which can be used to implement a private inner class, for example, which determines with each call that the \verb=sender= is indeed its parent class.

\section{Tags}

Each object has a couple of tags that the run-time installs by default - additional fields that aren't declared by the object itself. In particular, each object has its own mutex, refcount (number of references to the object - used for reference-based memory management), size, slots and lookup function.

As each object has its own mutex, unlike Apple's and GCC's run-times, where a pool of locks is used to minimize memory usage as well as the cost related to initializing a recursive mutex, even though some systems have lazy-initialization available. In Apple's and GCC's run-time, a hash is computed for each object, which determines which lock should be used. If it has already been taken by another object, another lock is used. The pool is claimed to be big enough, though, that in regular situations no contention is encountered. \'Etoil\'e's approach, however, decreases the contention to none at all.

Each object also has its own dispatch table, unlike the other run-times. This allows to change the dispatch object-based, i.e. swapping method implementations for just one object, adding a method for just one object, etc.

This leads to the last interesting tag, which is the lookup function. A lookup function is a function that goes through the dispatch table of the object and looks for the implementation of a method you want to call. Here, you can change the lookup function simply on an per-object basis, which allows to implement proxy objects very efficiently, making proxy calls virtually the same speed as direct calls (by setting the lookup function to a function that looks directly through the target class' methods).

\section{Metaclasses}

Another difference between the \'Etoil\'e run-time and the others is the lack of meta classes. The class methods are simply put into a dispatch table (in this case only a re-defined sparse array) directly on the class. In the traditional run-time, the instance methods have a dispatch table on the class, class methods are instance methods of its meta class. Here, the dispatch table of instance methods is installed directly onto the object, while the class methods have a dispatch table on the class itself. Hence no meta classes are needed in this run-time.

